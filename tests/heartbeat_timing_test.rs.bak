use fold::file_handler::{self, StateConfig};
use std::fs;

#[test]
fn test_txt_ingestion_creates_heartbeat() {
    let temp_dir = tempfile::tempdir().unwrap();
    let config = StateConfig::custom(temp_dir.path().to_path_buf());
    file_handler::initialize_with_config(&config).unwrap();

    // Create a txt file
    let txt_content = "test content for heartbeat";
    let input_dir = config.input_dir();
    fs::create_dir_all(&input_dir).unwrap();
    let txt_file = input_dir.join("test.txt");
    fs::write(&txt_file, txt_content).unwrap();

    // Ingest it
    let ingestion =
        file_handler::ingest_txt_file_with_config(txt_file.to_str().unwrap(), &config).unwrap();

    // Verify heartbeat was created in work folder
    let work_folder = format!("{}/test.txt.work", config.in_process_dir().display());
    let heartbeat = format!("{}/heartbeat", work_folder);
    assert!(
        std::path::Path::new(&heartbeat).exists(),
        "Heartbeat should be created in work folder"
    );

    // Cleanup the work folder
    ingestion.cleanup().unwrap();
}

#[test]
fn test_archive_merge_creates_heartbeat() {
    let temp_dir = tempfile::tempdir().unwrap();
    let config = StateConfig::custom(temp_dir.path().to_path_buf());
    file_handler::initialize_with_config(&config).unwrap();

    // Create two simple archives manually in input (archives don't have heartbeats in input)
    let input_dir = config.input_dir();
    fs::create_dir_all(&input_dir).unwrap();

    // Create archive_a manually
    let archive_a = input_dir.join("archive_a.bin");
    fs::create_dir_all(&archive_a).unwrap();
    fs::create_dir_all(archive_a.join("results")).unwrap();
    fs::write(archive_a.join("metadata.txt"), "5").unwrap();
    fs::write(archive_a.join("lineage.txt"), "\"a\"").unwrap();
    fs::write(archive_a.join("text_meta.txt"), "3\ntest a").unwrap();

    // Create archive_b manually
    let archive_b = input_dir.join("archive_b.bin");
    fs::create_dir_all(&archive_b).unwrap();
    fs::create_dir_all(archive_b.join("results")).unwrap();
    fs::write(archive_b.join("metadata.txt"), "3").unwrap();
    fs::write(archive_b.join("lineage.txt"), "\"b\"").unwrap();
    fs::write(archive_b.join("text_meta.txt"), "2\ntest b").unwrap();

    // Verify archives in input have NO heartbeats
    assert!(
        !archive_a.join("heartbeat").exists(),
        "Archive A in input/ should not have a heartbeat"
    );
    assert!(
        !archive_b.join("heartbeat").exists(),
        "Archive B in input/ should not have a heartbeat"
    );

    // Ingest them for merging (this moves them to in_process and adds heartbeats)
    let merge_ingestion =
        file_handler::ingest_archives_with_config(
            archive_a.to_str().unwrap(),
            archive_b.to_str().unwrap(),
            &config
        ).unwrap();

    // After moving to in_process, archives should have heartbeats
    let in_process_dir = config.in_process_dir();
    let mut found_archives_with_heartbeats = 0;

    for entry in fs::read_dir(&in_process_dir).unwrap() {
        let entry = entry.unwrap();
        let path = entry.path();
        if path.is_dir() && path.extension().map(|e| e == "bin").unwrap_or(false) {
            let heartbeat = path.join("heartbeat");
            if heartbeat.exists() {
                found_archives_with_heartbeats += 1;
            }
        }
    }

    assert_eq!(
        found_archives_with_heartbeats, 2,
        "Both archives in in_process/ should have heartbeats after being moved for merging"
    );

    merge_ingestion.cleanup().unwrap();
}

#[test]
fn test_stale_archives_in_process_are_recovered() {
    use filetime::{FileTime, set_file_mtime};

    let temp_dir = tempfile::tempdir().unwrap();
    let config = StateConfig::custom(temp_dir.path().to_path_buf());
    file_handler::initialize_with_config(&config).unwrap();

    // Create an archive directly in in_process with an old heartbeat
    let in_process_archive = config.in_process_dir().join("test_archive.bin");
    fs::create_dir_all(&in_process_archive).unwrap();

    // Create a results directory inside
    let results_dir = in_process_archive.join("results");
    fs::create_dir_all(&results_dir).unwrap();

    // Create metadata
    fs::write(in_process_archive.join("metadata.txt"), "10").unwrap();
    fs::write(in_process_archive.join("lineage.txt"), "test").unwrap();

    // Create a heartbeat file
    let heartbeat_path = in_process_archive.join("heartbeat");
    fs::write(&heartbeat_path, "test").unwrap();

    // Set the heartbeat file's modification time to 11 minutes ago
    let eleven_minutes_ago = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_secs()
        - 660; // 11 minutes = 660 seconds
    let file_time = FileTime::from_unix_time(eleven_minutes_ago as i64, 0);
    set_file_mtime(&heartbeat_path, file_time).unwrap();

    // Ensure input directory exists before recovery
    fs::create_dir_all(config.input_dir()).unwrap();

    // Run recovery
    file_handler::initialize_with_config(&config).unwrap();

    // Archive should have been moved to input
    let recovered_archive = config.input_dir().join("test_archive.bin");
    assert!(
        recovered_archive.exists(),
        "Stale archive should have been recovered to input/"
    );
    assert!(
        !in_process_archive.exists(),
        "Archive should no longer be in in_process/"
    );
}

#[test]
fn test_fresh_archives_in_process_are_not_recovered() {
    let temp_dir = tempfile::tempdir().unwrap();
    let config = StateConfig::custom(temp_dir.path().to_path_buf());
    file_handler::initialize_with_config(&config).unwrap();

    // Create an archive directly in in_process with a FRESH heartbeat
    let in_process_archive = config.in_process_dir().join("test_archive.bin");
    fs::create_dir_all(&in_process_archive).unwrap();

    // Create a results directory inside
    let results_dir = in_process_archive.join("results");
    fs::create_dir_all(&results_dir).unwrap();

    // Create metadata
    fs::write(in_process_archive.join("metadata.txt"), "10").unwrap();
    fs::write(in_process_archive.join("lineage.txt"), "test").unwrap();

    // Create a heartbeat file with a recent timestamp (1 minute ago)
    let heartbeat_path = in_process_archive.join("heartbeat");
    let one_minute_ago = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_secs()
        - 60; // 1 minute = 60 seconds
    fs::write(&heartbeat_path, one_minute_ago.to_string()).unwrap();

    // Run recovery
    file_handler::initialize_with_config(&config).unwrap();

    // Archive should still be in in_process
    assert!(
        in_process_archive.exists(),
        "Fresh archive should remain in in_process/"
    );

    // Archive should NOT be in input
    let would_be_recovered = config.input_dir().join("test_archive.bin");
    assert!(
        !would_be_recovered.exists(),
        "Fresh archive should not be recovered to input/"
    );
}
